{"ast":null,"code":"\"use strict\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _excluded = [\"screen\", \"if\"],\n  _excluded2 = [\"screens\", \"groups\"],\n  _excluded3 = [\"if\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\nimport { useRoute } from \"./useRoute.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar MemoizedScreen = React.memo(function (_ref) {\n  var component = _ref.component;\n  var route = useRoute();\n  var children = React.createElement(component, {\n    route: route\n  });\n  return children;\n});\nMemoizedScreen.displayName = 'Memo(Screen)';\nvar getItemsFromScreens = function getItemsFromScreens(Screen, screens) {\n  return Object.entries(screens).map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      name = _ref3[0],\n      item = _ref3[1];\n    var component;\n    var props = {};\n    var useIf;\n    var isNavigator = false;\n    if ('screen' in item) {\n      var screen = item.screen,\n        _if = item.if,\n        rest = _objectWithoutProperties(item, _excluded);\n      useIf = _if;\n      props = rest;\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, `${name}Navigator`);\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n    if (component == null) {\n      throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n    }\n    var element = isNavigator ? (React.createElement(component, {})) : _jsx(MemoizedScreen, {\n      component: component\n    });\n    return function () {\n      var shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return _jsx(Screen, _objectSpread(_objectSpread({\n        name: name\n      }, props), {}, {\n        children: function children() {\n          return element;\n        }\n      }), name);\n    };\n  });\n};\nexport function createComponentForStaticNavigation(tree, displayName) {\n  var Navigator = tree.Navigator,\n    Group = tree.Group,\n    Screen = tree.Screen,\n    config = tree.config;\n  var screens = config.screens,\n    groups = config.groups,\n    rest = _objectWithoutProperties(config, _excluded2);\n  if (screens == null && groups == null) {\n    throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");\n  }\n  var items = [];\n  for (var key in config) {\n    if (key === 'screens' && screens) {\n      items.push.apply(items, _toConsumableArray(getItemsFromScreens(Screen, screens)));\n    }\n    if (key === 'groups' && groups) {\n      items.push.apply(items, _toConsumableArray(Object.entries(groups).map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          key = _ref6[0],\n          _ref4 = _ref6[1];\n        var useIf = _ref4.if,\n          group = _objectWithoutProperties(_ref4, _excluded3);\n        var groupItems = getItemsFromScreens(Screen, group.screens);\n        return function () {\n          var children = groupItems.map(function (item) {\n            return item();\n          });\n          var shouldRender = useIf == null || useIf();\n          if (!shouldRender) {\n            return null;\n          }\n          return _jsx(Group, _objectSpread(_objectSpread({\n            navigationKey: key\n          }, group), {}, {\n            children: children\n          }), key);\n        };\n      })));\n    }\n  }\n  var NavigatorComponent = function NavigatorComponent() {\n    var children = items.map(function (item) {\n      return item();\n    });\n    return _jsx(Navigator, _objectSpread(_objectSpread({}, rest), {}, {\n      children: children\n    }));\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\nexport function createPathConfigForStaticNavigation(tree, options, auto) {\n  var initialScreenConfig;\n  var _createPathConfigForTree = function createPathConfigForTree(t, o, skipInitialDetection) {\n    var createPathConfigForScreens = function createPathConfigForScreens(screens, initialRouteName) {\n      return Object.fromEntries(Object.entries(screens).sort(function (_ref7, _ref8) {\n        var _ref9 = _slicedToArray(_ref7, 1),\n          a = _ref9[0];\n        var _ref0 = _slicedToArray(_ref8, 1),\n          b = _ref0[0];\n        if (a === initialRouteName) {\n          return -1;\n        }\n        if (b === initialRouteName) {\n          return 1;\n        }\n        return 0;\n      }).map(function (_ref1) {\n        var _ref10 = _slicedToArray(_ref1, 2),\n          key = _ref10[0],\n          item = _ref10[1];\n        var screenConfig = {};\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n          if (typeof screenConfig.path === 'string') {\n            screenConfig.path = screenConfig.path.replace(/^\\//, '').replace(/\\/$/, '');\n          }\n        }\n        var screens;\n        var skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';\n        if ('config' in item) {\n          screens = _createPathConfigForTree(item, undefined, skipInitialDetectionInChild);\n        } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {\n          screens = _createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);\n        }\n        if (screens) {\n          screenConfig.screens = screens;\n        }\n        if (auto && !screenConfig.screens && !('linking' in item && item.linking == null)) {\n          if (screenConfig.path != null) {\n            if (!skipInitialDetection && screenConfig.path === '') {\n              initialScreenConfig = undefined;\n            }\n          } else {\n            if (!skipInitialDetection && initialScreenConfig == null) {\n              initialScreenConfig = screenConfig;\n            }\n            screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();\n          }\n        }\n        return [key, screenConfig];\n      }).filter(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n          screen = _ref12[1];\n        return Object.keys(screen).length > 0;\n      }));\n    };\n    var screens = {};\n    for (var key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        var _o$initialRouteName;\n        Object.assign(screens, createPathConfigForScreens(t.config.screens, (_o$initialRouteName = o == null ? void 0 : o.initialRouteName) != null ? _o$initialRouteName : t.config.initialRouteName));\n      }\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(function (_ref13) {\n          var _o$initialRouteName2;\n          var _ref14 = _slicedToArray(_ref13, 2),\n            group = _ref14[1];\n          Object.assign(screens, createPathConfigForScreens(group.screens, (_o$initialRouteName2 = o == null ? void 0 : o.initialRouteName) != null ? _o$initialRouteName2 : t.config.initialRouteName));\n        });\n      }\n    }\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n    return screens;\n  };\n  var screens = _createPathConfigForTree(tree, options, false);\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n  return screens;\n}","map":{"version":3,"names":["React","isValidElementType","useRoute","jsx","_jsx","MemoizedScreen","memo","_ref","component","route","children","createElement","displayName","getItemsFromScreens","Screen","screens","Object","entries","map","_ref2","_ref3","_slicedToArray","name","item","props","useIf","isNavigator","screen","_if","if","rest","_objectWithoutProperties","_excluded","createComponentForStaticNavigation","Error","element","shouldRender","_objectSpread","tree","Navigator","Group","config","groups","_excluded2","items","key","push","apply","_toConsumableArray","_ref5","_ref6","_ref4","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","t","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","_ref7","_ref8","_ref9","a","_ref0","b","_ref1","_ref10","screenConfig","linking","path","assign","replace","skipInitialDetectionInChild","undefined","toLowerCase","filter","_ref11","_ref12","keys","length","_o$initialRouteName","forEach","_ref13","_o$initialRouteName2","_ref14"],"sources":["E:\\bigshow\\node_modules\\@react-navigation\\core\\src\\StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  RouteName,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\nexport type StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\nexport type StaticConfigGroup<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: StaticConfigGroup<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: StaticConfigGroup<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => React.JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group key={key} navigationKey={key} {...group}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n\n              if (typeof screenConfig.path === 'string') {\n                screenConfig.path = screenConfig.path\n                  .replace(/^\\//, '') // Remove extra leading slash\n                  .replace(/\\/$/, ''); // Remove extra trailing slash\n              }\n            }\n\n            let screens;\n\n            const skipInitialDetectionInChild =\n              skipInitialDetection ||\n              (screenConfig.path != null && screenConfig.path !== '');\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (\n              auto &&\n              !screenConfig.screens &&\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n              !('linking' in item && item.linking == null)\n            ) {\n              if (screenConfig.path != null) {\n                if (!skipInitialDetection && screenConfig.path === '') {\n                  // We encounter a leaf screen with empty path,\n                  // Clear the initial screen config as it's not needed anymore\n                  initialScreenConfig = undefined;\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}