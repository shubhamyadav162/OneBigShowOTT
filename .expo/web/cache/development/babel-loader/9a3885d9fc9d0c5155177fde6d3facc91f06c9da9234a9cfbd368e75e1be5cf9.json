{"ast":null,"code":"\"use strict\";\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar formatToList = function formatToList(items) {\n  return Object.entries(items).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      value = _ref2[1];\n    return `- ${key} (${value})`;\n  }).join('\\n');\n};\nexport function validatePathConfig(config) {\n  var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var validation = _objectSpread({\n    path: 'string',\n    initialRouteName: 'string',\n    screens: 'object'\n  }, root ? null : {\n    alias: 'array',\n    exact: 'boolean',\n    stringify: 'object',\n    parse: 'object'\n  });\n  if (typeof config !== 'object' || config === null) {\n    throw new Error(`Expected the configuration to be an object, but got ${JSON.stringify(config)}.`);\n  }\n  var validationErrors = Object.fromEntries(Object.keys(config).map(function (key) {\n    if (key in validation) {\n      var type = validation[key];\n      var value = config[key];\n      if (value !== undefined) {\n        if (type === 'array') {\n          if (!Array.isArray(value)) {\n            return [key, `expected 'Array', got '${typeof value}'`];\n          }\n        } else if (typeof value !== type) {\n          return [key, `expected '${type}', got '${typeof value}'`];\n        }\n      }\n    } else {\n      return [key, 'extraneous'];\n    }\n    return null;\n  }).filter(Boolean));\n  if (Object.keys(validationErrors).length) {\n    throw new Error(`Found invalid properties in the configuration:\\n${formatToList(validationErrors)}\\n\\nYou can only specify the following properties:\\n${formatToList(validation)}\\n\\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\\n\\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);\n  }\n  if (root && 'path' in config && typeof config.path === 'string' && config.path.includes(':')) {\n    throw new Error(`Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`);\n  }\n  if ('screens' in config && config.screens) {\n    Object.entries(config.screens).forEach(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        _ = _ref4[0],\n        value = _ref4[1];\n      if (typeof value !== 'string') {\n        validatePathConfig(value, false);\n      }\n    });\n  }\n}","map":{"version":3,"names":["formatToList","items","Object","entries","map","_ref","_ref2","_slicedToArray","key","value","join","validatePathConfig","config","root","arguments","length","undefined","validation","_objectSpread","path","initialRouteName","screens","alias","exact","stringify","parse","Error","JSON","validationErrors","fromEntries","keys","type","Array","isArray","filter","Boolean","includes","forEach","_ref3","_ref4","_"],"sources":["E:\\bigshow\\node_modules\\@react-navigation\\core\\src\\validatePathConfig.tsx"],"sourcesContent":["const formatToList = (items: Record<string, string>) =>\n  Object.entries(items)\n    .map(([key, value]) => `- ${key} (${value})`)\n    .join('\\n');\n\nexport function validatePathConfig(config: unknown, root = true) {\n  const validation = {\n    path: 'string',\n    initialRouteName: 'string',\n    screens: 'object',\n    ...(root\n      ? null\n      : {\n          alias: 'array',\n          exact: 'boolean',\n          stringify: 'object',\n          parse: 'object',\n        }),\n  };\n\n  if (typeof config !== 'object' || config === null) {\n    throw new Error(\n      `Expected the configuration to be an object, but got ${JSON.stringify(\n        config\n      )}.`\n    );\n  }\n\n  const validationErrors = Object.fromEntries(\n    Object.keys(config)\n      .map((key) => {\n        if (key in validation) {\n          const type = validation[key as keyof typeof validation];\n          // @ts-expect-error: we know the key exists\n          const value = config[key];\n\n          if (value !== undefined) {\n            if (type === 'array') {\n              if (!Array.isArray(value)) {\n                return [key, `expected 'Array', got '${typeof value}'`];\n              }\n            } else if (typeof value !== type) {\n              return [key, `expected '${type}', got '${typeof value}'`];\n            }\n          }\n        } else {\n          return [key, 'extraneous'];\n        }\n\n        return null;\n      })\n      .filter(Boolean) as [string, string][]\n  );\n\n  if (Object.keys(validationErrors).length) {\n    throw new Error(\n      `Found invalid properties in the configuration:\\n${formatToList(\n        validationErrors\n      )}\\n\\nYou can only specify the following properties:\\n${formatToList(\n        validation\n      )}\\n\\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\\n\\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`\n    );\n  }\n\n  if (\n    root &&\n    'path' in config &&\n    typeof config.path === 'string' &&\n    config.path.includes(':')\n  ) {\n    throw new Error(\n      `Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`\n    );\n  }\n\n  if ('screens' in config && config.screens) {\n    Object.entries(config.screens).forEach(([_, value]) => {\n      if (typeof value !== 'string') {\n        validatePathConfig(value, false);\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}