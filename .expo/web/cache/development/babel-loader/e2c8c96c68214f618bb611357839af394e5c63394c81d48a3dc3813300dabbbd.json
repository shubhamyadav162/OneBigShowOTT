{"ast":null,"code":"import _get from \"@babel/runtime/helpers/get\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport invariant from 'invariant';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport * as Base64 from \"./Base64\";\nimport { TokenError } from \"./Errors\";\nimport { requestAsync } from \"./Fetch\";\nimport { GrantType } from \"./TokenRequest.types\";\nexport function getCurrentTimeInSeconds() {\n  return Math.floor(Date.now() / 1000);\n}\nexport var TokenResponse = function () {\n  function TokenResponse(response) {\n    var _response$tokenType, _response$issuedAt;\n    _classCallCheck(this, TokenResponse);\n    this.accessToken = response.accessToken;\n    this.tokenType = (_response$tokenType = response.tokenType) != null ? _response$tokenType : 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = (_response$issuedAt = response.issuedAt) != null ? _response$issuedAt : getCurrentTimeInSeconds();\n  }\n  return _createClass(TokenResponse, [{\n    key: \"applyResponseConfig\",\n    value: function applyResponseConfig(response) {\n      var _response$accessToken, _ref, _response$tokenType2, _response$expiresIn, _response$refreshToke, _response$scope, _response$state, _response$idToken, _ref2, _response$issuedAt2;\n      this.accessToken = (_response$accessToken = response.accessToken) != null ? _response$accessToken : this.accessToken;\n      this.tokenType = (_ref = (_response$tokenType2 = response.tokenType) != null ? _response$tokenType2 : this.tokenType) != null ? _ref : 'bearer';\n      this.expiresIn = (_response$expiresIn = response.expiresIn) != null ? _response$expiresIn : this.expiresIn;\n      this.refreshToken = (_response$refreshToke = response.refreshToken) != null ? _response$refreshToke : this.refreshToken;\n      this.scope = (_response$scope = response.scope) != null ? _response$scope : this.scope;\n      this.state = (_response$state = response.state) != null ? _response$state : this.state;\n      this.idToken = (_response$idToken = response.idToken) != null ? _response$idToken : this.idToken;\n      this.issuedAt = (_ref2 = (_response$issuedAt2 = response.issuedAt) != null ? _response$issuedAt2 : this.issuedAt) != null ? _ref2 : getCurrentTimeInSeconds();\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        accessToken: this.accessToken,\n        idToken: this.idToken,\n        refreshToken: this.refreshToken,\n        scope: this.scope,\n        state: this.state,\n        tokenType: this.tokenType,\n        issuedAt: this.issuedAt,\n        expiresIn: this.expiresIn\n      };\n    }\n  }, {\n    key: \"refreshAsync\",\n    value: function () {\n      var _refreshAsync = _asyncToGenerator(function* (config, discovery) {\n        var _response$refreshToke2;\n        var request = new RefreshTokenRequest(_objectSpread(_objectSpread({}, config), {}, {\n          refreshToken: this.refreshToken\n        }));\n        var response = yield request.performAsync(discovery);\n        response.refreshToken = (_response$refreshToke2 = response.refreshToken) != null ? _response$refreshToke2 : this.refreshToken;\n        var json = response.getRequestConfig();\n        this.applyResponseConfig(json);\n        return this;\n      });\n      function refreshAsync(_x, _x2) {\n        return _refreshAsync.apply(this, arguments);\n      }\n      return refreshAsync;\n    }()\n  }, {\n    key: \"shouldRefresh\",\n    value: function shouldRefresh() {\n      return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n    }\n  }], [{\n    key: \"isTokenFresh\",\n    value: function isTokenFresh(token) {\n      var secondsMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60 * 10 * -1;\n      if (!token) {\n        return false;\n      }\n      if (token.expiresIn) {\n        var now = getCurrentTimeInSeconds();\n        return now < token.issuedAt + token.expiresIn + secondsMargin;\n      }\n      return true;\n    }\n  }, {\n    key: \"fromQueryParams\",\n    value: function fromQueryParams(params) {\n      return new TokenResponse({\n        accessToken: params.access_token,\n        refreshToken: params.refresh_token,\n        scope: params.scope,\n        state: params.state,\n        idToken: params.id_token,\n        tokenType: params.token_type,\n        expiresIn: params.expires_in,\n        issuedAt: params.issued_at\n      });\n    }\n  }]);\n}();\nvar Request = function () {\n  function Request(request) {\n    _classCallCheck(this, Request);\n    this.request = request;\n  }\n  return _createClass(Request, [{\n    key: \"performAsync\",\n    value: function () {\n      var _performAsync = _asyncToGenerator(function* (discovery) {\n        throw new Error('performAsync must be extended');\n      });\n      function performAsync(_x3) {\n        return _performAsync.apply(this, arguments);\n      }\n      return performAsync;\n    }()\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      throw new Error('getRequestConfig must be extended');\n    }\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      throw new Error('getQueryBody must be extended');\n    }\n  }]);\n}();\nvar TokenRequest = function (_Request) {\n  function TokenRequest(request, grantType) {\n    var _this;\n    _classCallCheck(this, TokenRequest);\n    _this = _callSuper(this, TokenRequest, [request]);\n    _this.grantType = grantType;\n    _this.clientId = request.clientId;\n    _this.clientSecret = request.clientSecret;\n    _this.extraParams = request.extraParams;\n    _this.scopes = request.scopes;\n    return _this;\n  }\n  _inherits(TokenRequest, _Request);\n  return _createClass(TokenRequest, [{\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n      if (typeof this.clientSecret !== 'undefined') {\n        var encodedClientId = encodeURIComponent(this.clientId);\n        var encodedClientSecret = encodeURIComponent(this.clientSecret);\n        var credentials = `${encodedClientId}:${encodedClientSecret}`;\n        var basicAuth = Base64.encodeNoWrap(credentials);\n        headers.Authorization = `Basic ${basicAuth}`;\n      }\n      return headers;\n    }\n  }, {\n    key: \"performAsync\",\n    value: function () {\n      var _performAsync2 = _asyncToGenerator(function* (discovery) {\n        invariant(discovery.tokenEndpoint, `Cannot invoke \\`performAsync()\\` without a valid tokenEndpoint`);\n        var response = yield requestAsync(discovery.tokenEndpoint, {\n          dataType: 'json',\n          method: 'POST',\n          headers: this.getHeaders(),\n          body: this.getQueryBody()\n        });\n        if ('error' in response) {\n          throw new TokenError(response);\n        }\n        return new TokenResponse({\n          accessToken: response.access_token,\n          tokenType: response.token_type,\n          expiresIn: response.expires_in,\n          refreshToken: response.refresh_token,\n          scope: response.scope,\n          idToken: response.id_token,\n          issuedAt: response.issued_at\n        });\n      });\n      function performAsync(_x4) {\n        return _performAsync2.apply(this, arguments);\n      }\n      return performAsync;\n    }()\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = {\n        grant_type: this.grantType\n      };\n      if (!this.clientSecret) {\n        queryBody.client_id = this.clientId;\n      }\n      if (this.scopes) {\n        queryBody.scope = this.scopes.join(' ');\n      }\n      if (this.extraParams) {\n        for (var extra in this.extraParams) {\n          if (extra in this.extraParams && !(extra in queryBody)) {\n            queryBody[extra] = this.extraParams[extra];\n          }\n        }\n      }\n      return queryBody;\n    }\n  }]);\n}(Request);\nexport var AccessTokenRequest = function (_TokenRequest) {\n  function AccessTokenRequest(options) {\n    var _this2;\n    _classCallCheck(this, AccessTokenRequest);\n    invariant(options.redirectUri, `\\`AccessTokenRequest\\` requires a valid \\`redirectUri\\` (it must also match the one used in the auth request). Example: ${Platform.select({\n      web: 'https://yourwebsite.com/redirect',\n      default: 'myapp://redirect'\n    })}`);\n    invariant(options.code, `\\`AccessTokenRequest\\` requires a valid authorization \\`code\\`. This is what's received from the authorization server after an auth request.`);\n    _this2 = _callSuper(this, AccessTokenRequest, [options, GrantType.AuthorizationCode]);\n    _this2.code = options.code;\n    _this2.redirectUri = options.redirectUri;\n    return _this2;\n  }\n  _inherits(AccessTokenRequest, _TokenRequest);\n  return _createClass(AccessTokenRequest, [{\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = _superPropGet(AccessTokenRequest, \"getQueryBody\", this, 3)([]);\n      if (this.redirectUri) {\n        queryBody.redirect_uri = this.redirectUri;\n      }\n      if (this.code) {\n        queryBody.code = this.code;\n      }\n      return queryBody;\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        grantType: this.grantType,\n        code: this.code,\n        redirectUri: this.redirectUri,\n        extraParams: this.extraParams,\n        scopes: this.scopes\n      };\n    }\n  }]);\n}(TokenRequest);\nexport var RefreshTokenRequest = function (_TokenRequest2) {\n  function RefreshTokenRequest(options) {\n    var _this3;\n    _classCallCheck(this, RefreshTokenRequest);\n    invariant(options.refreshToken, `\\`RefreshTokenRequest\\` requires a valid \\`refreshToken\\`.`);\n    _this3 = _callSuper(this, RefreshTokenRequest, [options, GrantType.RefreshToken]);\n    _this3.refreshToken = options.refreshToken;\n    return _this3;\n  }\n  _inherits(RefreshTokenRequest, _TokenRequest2);\n  return _createClass(RefreshTokenRequest, [{\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = _superPropGet(RefreshTokenRequest, \"getQueryBody\", this, 3)([]);\n      if (this.refreshToken) {\n        queryBody.refresh_token = this.refreshToken;\n      }\n      return queryBody;\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        grantType: this.grantType,\n        refreshToken: this.refreshToken,\n        extraParams: this.extraParams,\n        scopes: this.scopes\n      };\n    }\n  }]);\n}(TokenRequest);\nexport var RevokeTokenRequest = function (_Request2) {\n  function RevokeTokenRequest(request) {\n    var _this4;\n    _classCallCheck(this, RevokeTokenRequest);\n    _this4 = _callSuper(this, RevokeTokenRequest, [request]);\n    invariant(request.token, `\\`RevokeTokenRequest\\` requires a valid \\`token\\` to revoke.`);\n    _this4.clientId = request.clientId;\n    _this4.clientSecret = request.clientSecret;\n    _this4.token = request.token;\n    _this4.tokenTypeHint = request.tokenTypeHint;\n    return _this4;\n  }\n  _inherits(RevokeTokenRequest, _Request2);\n  return _createClass(RevokeTokenRequest, [{\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n      if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n        var encodedClientId = encodeURIComponent(this.clientId);\n        var encodedClientSecret = encodeURIComponent(this.clientSecret);\n        var credentials = `${encodedClientId}:${encodedClientSecret}`;\n        var basicAuth = Base64.encodeNoWrap(credentials);\n        headers.Authorization = `Basic ${basicAuth}`;\n      }\n      return headers;\n    }\n  }, {\n    key: \"performAsync\",\n    value: (function () {\n      var _performAsync3 = _asyncToGenerator(function* (discovery) {\n        invariant(discovery.revocationEndpoint, `Cannot invoke \\`performAsync()\\` without a valid revocationEndpoint`);\n        yield requestAsync(discovery.revocationEndpoint, {\n          method: 'POST',\n          headers: this.getHeaders(),\n          body: this.getQueryBody()\n        });\n        return true;\n      });\n      function performAsync(_x5) {\n        return _performAsync3.apply(this, arguments);\n      }\n      return performAsync;\n    }())\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        token: this.token,\n        tokenTypeHint: this.tokenTypeHint\n      };\n    }\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = {\n        token: this.token\n      };\n      if (this.tokenTypeHint) {\n        queryBody.token_type_hint = this.tokenTypeHint;\n      }\n      if (this.clientId) {\n        queryBody.client_id = this.clientId;\n      }\n      if (this.clientSecret) {\n        queryBody.client_secret = this.clientSecret;\n      }\n      return queryBody;\n    }\n  }]);\n}(Request);\nexport function exchangeCodeAsync(config, discovery) {\n  var request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function refreshAsync(config, discovery) {\n  var request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function revokeAsync(config, discovery) {\n  var request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function fetchUserInfoAsync(config, discovery) {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n  return requestAsync(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Bearer ${config.accessToken}`\n    },\n    dataType: 'json',\n    method: 'GET'\n  });\n}","map":{"version":3,"names":["invariant","Platform","Base64","TokenError","requestAsync","GrantType","getCurrentTimeInSeconds","Math","floor","Date","now","TokenResponse","response","_response$tokenType","_response$issuedAt","_classCallCheck","accessToken","tokenType","expiresIn","refreshToken","scope","state","idToken","issuedAt","_createClass","key","value","applyResponseConfig","_response$accessToken","_ref","_response$tokenType2","_response$expiresIn","_response$refreshToke","_response$scope","_response$state","_response$idToken","_ref2","_response$issuedAt2","getRequestConfig","_refreshAsync","_asyncToGenerator","config","discovery","_response$refreshToke2","request","RefreshTokenRequest","_objectSpread","performAsync","json","refreshAsync","_x","_x2","apply","arguments","shouldRefresh","isTokenFresh","token","secondsMargin","length","undefined","fromQueryParams","params","access_token","refresh_token","id_token","token_type","expires_in","issued_at","Request","_performAsync","Error","_x3","getQueryBody","TokenRequest","_Request","grantType","_this","_callSuper","clientId","clientSecret","extraParams","scopes","_inherits","getHeaders","headers","encodedClientId","encodeURIComponent","encodedClientSecret","credentials","basicAuth","encodeNoWrap","Authorization","_performAsync2","tokenEndpoint","dataType","method","body","_x4","queryBody","grant_type","client_id","join","extra","AccessTokenRequest","_TokenRequest","options","_this2","redirectUri","select","web","default","code","AuthorizationCode","_superPropGet","redirect_uri","_TokenRequest2","_this3","RefreshToken","RevokeTokenRequest","_Request2","_this4","tokenTypeHint","_performAsync3","revocationEndpoint","_x5","token_type_hint","client_secret","exchangeCodeAsync","revokeAsync","fetchUserInfoAsync","userInfoEndpoint"],"sources":["E:\\bigshow\\node_modules\\expo-auth-session\\src\\TokenRequest.ts"],"sourcesContent":["import invariant from 'invariant';\nimport { Platform } from 'react-native';\n\nimport * as Base64 from './Base64';\nimport * as ServiceConfig from './Discovery';\nimport { ResponseErrorConfig, TokenError } from './Errors';\nimport { Headers, requestAsync } from './Fetch';\nimport {\n  AccessTokenRequestConfig,\n  GrantType,\n  RefreshTokenRequestConfig,\n  RevokeTokenRequestConfig,\n  ServerTokenResponseConfig,\n  TokenRequestConfig,\n  TokenResponseConfig,\n  TokenType,\n  TokenTypeHint,\n} from './TokenRequest.types';\n\n/**\n * Returns the current time in seconds.\n */\nexport function getCurrentTimeInSeconds(): number {\n  return Math.floor(Date.now() / 1000);\n}\n\n/**\n * Token Response.\n *\n * [Section 5.1](https://tools.ietf.org/html/rfc6749#section-5.1)\n */\nexport class TokenResponse implements TokenResponseConfig {\n  /**\n   * Determines whether a token refresh request must be made to refresh the tokens\n   *\n   * @param token\n   * @param secondsMargin\n   */\n  static isTokenFresh(\n    token: Pick<TokenResponse, 'expiresIn' | 'issuedAt'>,\n    /**\n     * -10 minutes in seconds\n     */\n    secondsMargin: number = 60 * 10 * -1\n  ): boolean {\n    if (!token) {\n      return false;\n    }\n    if (token.expiresIn) {\n      const now = getCurrentTimeInSeconds();\n      return now < token.issuedAt + token.expiresIn + secondsMargin;\n    }\n    // if there is no expiration time but we have an access token, it is assumed to never expire\n    return true;\n  }\n  /**\n   * Creates a `TokenResponse` from query parameters returned from an `AuthRequest`.\n   *\n   * @param params\n   */\n  static fromQueryParams(params: Record<string, any>): TokenResponse {\n    return new TokenResponse({\n      accessToken: params.access_token,\n      refreshToken: params.refresh_token,\n      scope: params.scope,\n      state: params.state,\n      idToken: params.id_token,\n      tokenType: params.token_type,\n      expiresIn: params.expires_in,\n      issuedAt: params.issued_at,\n    });\n  }\n\n  accessToken: string;\n  tokenType: TokenType;\n  expiresIn?: number;\n  refreshToken?: string;\n  scope?: string;\n  state?: string;\n  idToken?: string;\n  issuedAt: number;\n\n  constructor(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken;\n    this.tokenType = response.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = response.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  private applyResponseConfig(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken ?? this.accessToken;\n    this.tokenType = response.tokenType ?? this.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn ?? this.expiresIn;\n    this.refreshToken = response.refreshToken ?? this.refreshToken;\n    this.scope = response.scope ?? this.scope;\n    this.state = response.state ?? this.state;\n    this.idToken = response.idToken ?? this.idToken;\n    this.issuedAt = response.issuedAt ?? this.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  getRequestConfig(): TokenResponseConfig {\n    return {\n      accessToken: this.accessToken,\n      idToken: this.idToken,\n      refreshToken: this.refreshToken,\n      scope: this.scope,\n      state: this.state,\n      tokenType: this.tokenType,\n      issuedAt: this.issuedAt,\n      expiresIn: this.expiresIn,\n    };\n  }\n\n  async refreshAsync(\n    config: Omit<TokenRequestConfig, 'grantType' | 'refreshToken'>,\n    discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n  ): Promise<TokenResponse> {\n    const request = new RefreshTokenRequest({\n      ...config,\n      refreshToken: this.refreshToken,\n    });\n    const response = await request.performAsync(discovery);\n    // Custom: reuse the refresh token if one wasn't returned\n    response.refreshToken = response.refreshToken ?? this.refreshToken;\n    const json = response.getRequestConfig();\n    this.applyResponseConfig(json);\n    return this;\n  }\n\n  shouldRefresh(): boolean {\n    // no refresh token available and token has expired\n    return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n  }\n}\n\nclass Request<T, B> {\n  constructor(protected request: T) {}\n\n  async performAsync(discovery: ServiceConfig.DiscoveryDocument): Promise<B> {\n    throw new Error('performAsync must be extended');\n  }\n\n  getRequestConfig(): T {\n    throw new Error('getRequestConfig must be extended');\n  }\n\n  getQueryBody(): Record<string, string> {\n    throw new Error('getQueryBody must be extended');\n  }\n}\n\n/**\n * A generic token request.\n */\nclass TokenRequest<T extends TokenRequestConfig> extends Request<T, TokenResponse> {\n  readonly clientId: string;\n  readonly clientSecret?: string;\n  readonly scopes?: string[];\n  readonly extraParams?: Record<string, string>;\n\n  constructor(request, public grantType: GrantType) {\n    super(request);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.extraParams = request.extraParams;\n    this.scopes = request.scopes;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined') {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>) {\n    // redirect URI must not be nil\n    invariant(\n      discovery.tokenEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid tokenEndpoint`\n    );\n    const response = await requestAsync<ServerTokenResponseConfig | ResponseErrorConfig>(\n      discovery.tokenEndpoint,\n      {\n        dataType: 'json',\n        method: 'POST',\n        headers: this.getHeaders(),\n        body: this.getQueryBody(),\n      }\n    );\n\n    if ('error' in response) {\n      throw new TokenError(response);\n    }\n\n    return new TokenResponse({\n      accessToken: response.access_token,\n      tokenType: response.token_type,\n      expiresIn: response.expires_in,\n      refreshToken: response.refresh_token,\n      scope: response.scope,\n      idToken: response.id_token,\n      issuedAt: response.issued_at,\n    });\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = {\n      grant_type: this.grantType,\n    };\n\n    if (!this.clientSecret) {\n      // Only add the client ID if client secret is not present, otherwise pass the client id with the secret in the request body.\n      queryBody.client_id = this.clientId;\n    }\n\n    if (this.scopes) {\n      queryBody.scope = this.scopes.join(' ');\n    }\n\n    if (this.extraParams) {\n      for (const extra in this.extraParams) {\n        if (extra in this.extraParams && !(extra in queryBody)) {\n          queryBody[extra] = this.extraParams[extra];\n        }\n      }\n    }\n    return queryBody;\n  }\n}\n\n/**\n * Access token request. Exchange an authorization code for a user access token.\n *\n * [Section 4.1.3](https://tools.ietf.org/html/rfc6749#section-4.1.3)\n */\nexport class AccessTokenRequest\n  extends TokenRequest<AccessTokenRequestConfig>\n  implements AccessTokenRequestConfig\n{\n  readonly code: string;\n  readonly redirectUri: string;\n\n  constructor(options: AccessTokenRequestConfig) {\n    invariant(\n      options.redirectUri,\n      `\\`AccessTokenRequest\\` requires a valid \\`redirectUri\\` (it must also match the one used in the auth request). Example: ${Platform.select(\n        {\n          web: 'https://yourwebsite.com/redirect',\n          default: 'myapp://redirect',\n        }\n      )}`\n    );\n\n    invariant(\n      options.code,\n      `\\`AccessTokenRequest\\` requires a valid authorization \\`code\\`. This is what's received from the authorization server after an auth request.`\n    );\n    super(options, GrantType.AuthorizationCode);\n    this.code = options.code;\n    this.redirectUri = options.redirectUri;\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = super.getQueryBody();\n\n    if (this.redirectUri) {\n      queryBody.redirect_uri = this.redirectUri;\n    }\n\n    if (this.code) {\n      queryBody.code = this.code;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      code: this.code,\n      redirectUri: this.redirectUri,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Refresh request.\n *\n * [Section 6](https://tools.ietf.org/html/rfc6749#section-6)\n */\nexport class RefreshTokenRequest\n  extends TokenRequest<RefreshTokenRequestConfig>\n  implements RefreshTokenRequestConfig\n{\n  readonly refreshToken?: string;\n\n  constructor(options: RefreshTokenRequestConfig) {\n    invariant(options.refreshToken, `\\`RefreshTokenRequest\\` requires a valid \\`refreshToken\\`.`);\n    super(options, GrantType.RefreshToken);\n    this.refreshToken = options.refreshToken;\n  }\n\n  getQueryBody() {\n    const queryBody = super.getQueryBody();\n\n    if (this.refreshToken) {\n      queryBody.refresh_token = this.refreshToken;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      refreshToken: this.refreshToken,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Revocation request for a given token.\n *\n * [Section 2.1](https://tools.ietf.org/html/rfc7009#section-2.1)\n */\nexport class RevokeTokenRequest\n  extends Request<RevokeTokenRequestConfig, boolean>\n  implements RevokeTokenRequestConfig\n{\n  readonly clientId?: string;\n  readonly clientSecret?: string;\n  readonly token: string;\n  readonly tokenTypeHint?: TokenTypeHint;\n\n  constructor(request: RevokeTokenRequestConfig) {\n    super(request);\n    invariant(request.token, `\\`RevokeTokenRequest\\` requires a valid \\`token\\` to revoke.`);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.token = request.token;\n    this.tokenTypeHint = request.tokenTypeHint;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  /**\n   * Perform a token revocation request.\n   *\n   * @param discovery The `revocationEndpoint` for a provider.\n   */\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>) {\n    invariant(\n      discovery.revocationEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid revocationEndpoint`\n    );\n    await requestAsync<boolean>(discovery.revocationEndpoint, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: this.getQueryBody(),\n    });\n\n    return true;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      token: this.token,\n      tokenTypeHint: this.tokenTypeHint,\n    };\n  }\n\n  getQueryBody(): Record<string, string> {\n    const queryBody: Record<string, string> = { token: this.token };\n    if (this.tokenTypeHint) {\n      queryBody.token_type_hint = this.tokenTypeHint;\n    }\n    // Include client creds https://tools.ietf.org/html/rfc6749#section-2.3.1\n    if (this.clientId) {\n      queryBody.client_id = this.clientId;\n    }\n    if (this.clientSecret) {\n      queryBody.client_secret = this.clientSecret;\n    }\n    return queryBody;\n  }\n}\n\n// @needsAudit\n/**\n * Exchange an authorization code for an access token that can be used to get data from the provider.\n *\n * @param config Configuration used to exchange the code for a token.\n * @param discovery The `tokenEndpoint` for a provider.\n * @return Returns a discovery document with a valid `tokenEndpoint` URL.\n */\nexport function exchangeCodeAsync(\n  config: AccessTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n// @needsAudit\n/**\n * Refresh an access token.\n * - If the provider didn't return a `refresh_token` then the access token may not be refreshed.\n * - If the provider didn't return a `expires_in` then it's assumed that the token does not expire.\n * - Determine if a token needs to be refreshed via `TokenResponse.isTokenFresh()` or `shouldRefresh()` on an instance of `TokenResponse`.\n *\n * @see [Section 6](https://tools.ietf.org/html/rfc6749#section-6).\n *\n * @param config Configuration used to refresh the given access token.\n * @param discovery The `tokenEndpoint` for a provider.\n * @return Returns a discovery document with a valid `tokenEndpoint` URL.\n */\nexport function refreshAsync(\n  config: RefreshTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n// @needsAudit\n/**\n * Revoke a token with a provider. This makes the token unusable, effectively requiring the user to login again.\n *\n * @param config Configuration used to revoke a refresh or access token.\n * @param discovery The `revocationEndpoint` for a provider.\n * @return Returns a discovery document with a valid `revocationEndpoint` URL. Many providers do not support this feature.\n */\nexport function revokeAsync(\n  config: RevokeTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>\n): Promise<boolean> {\n  const request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n/**\n * Fetch generic user info from the provider's OpenID Connect `userInfoEndpoint` (if supported).\n *\n * @see [UserInfo](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).\n *\n * @param config The `accessToken` for a user, returned from a code exchange or auth request.\n * @param discovery The `userInfoEndpoint` for a provider.\n */\nexport function fetchUserInfoAsync(\n  config: Pick<TokenResponse, 'accessToken'>,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'userInfoEndpoint'>\n): Promise<Record<string, any>> {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n  return requestAsync<Record<string, any>>(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Bearer ${config.accessToken}`,\n    },\n    dataType: 'json',\n    method: 'GET',\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}