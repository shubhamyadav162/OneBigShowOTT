{"ast":null,"code":"\"use strict\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nexport function getPatternParts(path) {\n  var parts = [];\n  var current = {\n    segment: ''\n  };\n  var isRegex = false;\n  var isParam = false;\n  var regexInnerParens = 0;\n  for (var i = 0; i <= path.length; i++) {\n    var char = path[i];\n    if (char != null) {\n      current.segment += char;\n    }\n    if (char === ':') {\n      if (current.segment === ':') {\n        isParam = true;\n      } else if (!isRegex) {\n        throw new Error(`Encountered ':' in the middle of a segment in path: ${path}`);\n      }\n    } else if (char === '(') {\n      if (isParam) {\n        if (isRegex) {\n          regexInnerParens++;\n        } else {\n          isRegex = true;\n        }\n      } else {\n        throw new Error(`Encountered '(' without preceding ':' in path: ${path}`);\n      }\n    } else if (char === ')') {\n      if (isParam && isRegex) {\n        if (regexInnerParens) {\n          regexInnerParens--;\n          current.regex += char;\n        } else {\n          isRegex = false;\n          isParam = false;\n        }\n      } else {\n        throw new Error(`Encountered ')' without preceding '(' in path: ${path}`);\n      }\n    } else if (char === '?') {\n      if (current.param) {\n        isParam = false;\n        current.optional = true;\n      } else {\n        throw new Error(`Encountered '?' without preceding ':' in path: ${path}`);\n      }\n    } else if (char == null || char === '/' && !isRegex) {\n      isParam = false;\n      current.segment = current.segment.replace(/\\/$/, '');\n      if (current.segment === '') {\n        continue;\n      }\n      if (current.param) {\n        current.param = current.param.replace(/^:/, '');\n      }\n      if (current.regex) {\n        current.regex = current.regex.replace(/^\\(/, '').replace(/\\)$/, '');\n      }\n      parts.push(current);\n      if (char == null) {\n        break;\n      }\n      current = {\n        segment: ''\n      };\n    }\n    if (isRegex) {\n      current.regex = current.regex || '';\n      current.regex += char;\n    }\n    if (isParam && !isRegex) {\n      current.param = current.param || '';\n      current.param += char;\n    }\n  }\n  if (isRegex) {\n    throw new Error(`Could not find closing ')' in path: ${path}`);\n  }\n  var params = parts.map(function (part) {\n    return part.param;\n  }).filter(Boolean);\n  for (var _ref of params.entries()) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    var index = _ref2[0];\n    var param = _ref2[1];\n    if (params.indexOf(param) !== index) {\n      throw new Error(`Duplicate param name '${param}' found in path: ${path}`);\n    }\n  }\n  return parts;\n}","map":{"version":3,"names":["getPatternParts","path","parts","current","segment","isRegex","isParam","regexInnerParens","i","length","char","Error","regex","param","optional","replace","push","params","map","part","filter","Boolean","_ref","entries","_ref2","_slicedToArray","index","indexOf"],"sources":["E:\\bigshow\\node_modules\\@react-navigation\\core\\src\\getPatternParts.tsx"],"sourcesContent":["export type PatternPart = {\n  segment: string;\n  param?: string;\n  regex?: string;\n  optional?: boolean;\n};\n\n/**\n * Parse a path into an array of parts with information about each segment.\n */\nexport function getPatternParts(path: string): PatternPart[] {\n  const parts: PatternPart[] = [];\n\n  let current: PatternPart = { segment: '' };\n\n  let isRegex = false;\n  let isParam = false;\n  let regexInnerParens = 0;\n\n  // One extra iteration to add the last character\n  for (let i = 0; i <= path.length; i++) {\n    const char = path[i];\n\n    if (char != null) {\n      current.segment += char;\n    }\n\n    if (char === ':') {\n      // The segment must start with a colon if it's a param\n      if (current.segment === ':') {\n        isParam = true;\n      } else if (!isRegex) {\n        throw new Error(\n          `Encountered ':' in the middle of a segment in path: ${path}`\n        );\n      }\n    } else if (char === '(') {\n      if (isParam) {\n        if (isRegex) {\n          // The '(' is part of the regex if we're already inside one\n          regexInnerParens++;\n        } else {\n          isRegex = true;\n        }\n      } else {\n        throw new Error(\n          `Encountered '(' without preceding ':' in path: ${path}`\n        );\n      }\n    } else if (char === ')') {\n      if (isParam && isRegex) {\n        if (regexInnerParens) {\n          // The ')' is part of the regex if we're already inside one\n          regexInnerParens--;\n          current.regex += char;\n        } else {\n          isRegex = false;\n          isParam = false;\n        }\n      } else {\n        throw new Error(\n          `Encountered ')' without preceding '(' in path: ${path}`\n        );\n      }\n    } else if (char === '?') {\n      if (current.param) {\n        isParam = false;\n\n        current.optional = true;\n      } else {\n        throw new Error(\n          `Encountered '?' without preceding ':' in path: ${path}`\n        );\n      }\n    } else if (char == null || (char === '/' && !isRegex)) {\n      isParam = false;\n\n      // Remove trailing slash from segment\n      current.segment = current.segment.replace(/\\/$/, '');\n\n      if (current.segment === '') {\n        continue;\n      }\n\n      if (current.param) {\n        current.param = current.param.replace(/^:/, '');\n      }\n\n      if (current.regex) {\n        current.regex = current.regex.replace(/^\\(/, '').replace(/\\)$/, '');\n      }\n\n      parts.push(current);\n\n      if (char == null) {\n        break;\n      }\n\n      current = { segment: '' };\n    }\n\n    if (isRegex) {\n      current.regex = current.regex || '';\n      current.regex += char;\n    }\n\n    if (isParam && !isRegex) {\n      current.param = current.param || '';\n      current.param += char;\n    }\n  }\n\n  if (isRegex) {\n    throw new Error(`Could not find closing ')' in path: ${path}`);\n  }\n\n  const params = parts.map((part) => part.param).filter(Boolean);\n\n  for (const [index, param] of params.entries()) {\n    if (params.indexOf(param) !== index) {\n      throw new Error(`Duplicate param name '${param}' found in path: ${path}`);\n    }\n  }\n\n  return parts;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}