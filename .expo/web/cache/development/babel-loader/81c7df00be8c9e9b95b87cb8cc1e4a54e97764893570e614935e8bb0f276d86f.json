{"ast":null,"code":"\"use strict\";\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { CommonActions, findFocusedRoute, getActionFromState, getPathFromState, getStateFromPath, NavigationHelpersContext, NavigationRouteContext, useStateForPath } from '@react-navigation/core';\nimport * as React from 'react';\nimport { LinkingContext } from \"./LinkingContext.js\";\nexport function useLinkBuilder() {\n  var _options$getPathFromS, _options$getStateFrom, _options$getActionFro;\n  var navigation = React.useContext(NavigationHelpersContext);\n  var route = React.useContext(NavigationRouteContext);\n  var _React$useContext = React.useContext(LinkingContext),\n    options = _React$useContext.options;\n  var focusedRouteState = useStateForPath();\n  var getPathFromStateHelper = (_options$getPathFromS = options == null ? void 0 : options.getPathFromState) != null ? _options$getPathFromS : getPathFromState;\n  var getStateFromPathHelper = (_options$getStateFrom = options == null ? void 0 : options.getStateFromPath) != null ? _options$getStateFrom : getStateFromPath;\n  var getActionFromStateHelper = (_options$getActionFro = options == null ? void 0 : options.getActionFromState) != null ? _options$getActionFro : getActionFromState;\n  var buildHref = React.useCallback(function (name, params) {\n    var _findFocusedRoute;\n    if ((options == null ? void 0 : options.enabled) === false) {\n      return undefined;\n    }\n    var isScreen = navigation && route != null && route.key && focusedRouteState ? route.key === ((_findFocusedRoute = findFocusedRoute(focusedRouteState)) == null ? void 0 : _findFocusedRoute.key) && navigation.getState().routes.some(function (r) {\n      return r.key === route.key;\n    }) : false;\n    var stateForRoute = {\n      routes: [{\n        name: name,\n        params: params\n      }]\n    };\n    var _constructState = function constructState(state) {\n      if (state) {\n        var _route = state.routes[0];\n        if (isScreen && !_route.state) {\n          return stateForRoute;\n        }\n        return {\n          routes: [_objectSpread(_objectSpread({}, _route), {}, {\n            state: _constructState(_route.state)\n          })]\n        };\n      }\n      return stateForRoute;\n    };\n    var state = _constructState(focusedRouteState);\n    var path = getPathFromStateHelper(state, options == null ? void 0 : options.config);\n    return path;\n  }, [options == null ? void 0 : options.enabled, options == null ? void 0 : options.config, route == null ? void 0 : route.key, navigation, focusedRouteState, getPathFromStateHelper]);\n  var buildAction = React.useCallback(function (href) {\n    if (!href.startsWith('/')) {\n      throw new Error(`The href must start with '/' (${href}).`);\n    }\n    var state = getStateFromPathHelper(href, options == null ? void 0 : options.config);\n    if (state) {\n      var action = getActionFromStateHelper(state, options == null ? void 0 : options.config);\n      return action != null ? action : CommonActions.reset(state);\n    } else {\n      throw new Error('Failed to parse the href to a navigation state.');\n    }\n  }, [options == null ? void 0 : options.config, getStateFromPathHelper, getActionFromStateHelper]);\n  return {\n    buildHref: buildHref,\n    buildAction: buildAction\n  };\n}","map":{"version":3,"names":["CommonActions","findFocusedRoute","getActionFromState","getPathFromState","getStateFromPath","NavigationHelpersContext","NavigationRouteContext","useStateForPath","React","LinkingContext","useLinkBuilder","_options$getPathFromS","_options$getStateFrom","_options$getActionFro","navigation","useContext","route","_React$useContext","options","focusedRouteState","getPathFromStateHelper","getStateFromPathHelper","getActionFromStateHelper","buildHref","useCallback","name","params","_findFocusedRoute","enabled","undefined","isScreen","key","getState","routes","some","r","stateForRoute","constructState","state","_objectSpread","path","config","buildAction","href","startsWith","Error","action","reset"],"sources":["E:\\bigshow\\node_modules\\@react-navigation\\native\\src\\useLinkBuilder.tsx"],"sourcesContent":["import {\n  CommonActions,\n  findFocusedRoute,\n  getActionFromState,\n  getPathFromState,\n  getStateFromPath,\n  NavigationHelpersContext,\n  NavigationRouteContext,\n  useStateForPath,\n} from '@react-navigation/core';\nimport * as React from 'react';\n\nimport { LinkingContext } from './LinkingContext';\n\ntype MinimalState = {\n  routes: [{ name: string; params?: object; state?: MinimalState }];\n};\n\n/**\n * Helpers to build href or action based on the linking options.\n *\n * @returns `buildHref` to build an `href` for screen and `buildAction` to build an action from an `href`.\n */\nexport function useLinkBuilder() {\n  const navigation = React.useContext(NavigationHelpersContext);\n  const route = React.useContext(NavigationRouteContext);\n\n  const { options } = React.useContext(LinkingContext);\n\n  const focusedRouteState = useStateForPath();\n\n  const getPathFromStateHelper = options?.getPathFromState ?? getPathFromState;\n  const getStateFromPathHelper = options?.getStateFromPath ?? getStateFromPath;\n  const getActionFromStateHelper =\n    options?.getActionFromState ?? getActionFromState;\n\n  const buildHref = React.useCallback(\n    (name: string, params?: object) => {\n      if (options?.enabled === false) {\n        return undefined;\n      }\n\n      // Check that we're inside:\n      // - navigator's context\n      // - route context of the navigator (could be a screen, tab, etc.)\n      // - route matches the state for path (from the screen's context)\n      // This ensures that we're inside a screen\n      const isScreen =\n        navigation && route?.key && focusedRouteState\n          ? route.key === findFocusedRoute(focusedRouteState)?.key &&\n            navigation.getState().routes.some((r) => r.key === route.key)\n          : false;\n\n      const stateForRoute: MinimalState = {\n        routes: [{ name, params }],\n      };\n\n      const constructState = (\n        state: MinimalState | undefined\n      ): MinimalState => {\n        if (state) {\n          const route = state.routes[0];\n\n          // If we're inside a screen and at the innermost route\n          // We need to replace the state with the provided one\n          // This assumes that we're navigating to a sibling route\n          if (isScreen && !route.state) {\n            return stateForRoute;\n          }\n\n          // Otherwise, dive into the nested state of the route\n          return {\n            routes: [\n              {\n                ...route,\n                state: constructState(route.state),\n              },\n            ],\n          };\n        }\n\n        // Once there is no more nested state, we're at the innermost route\n        // We can add a state based on provided parameters\n        // This assumes that we're navigating to a child of this route\n        // In this case, the helper is used in a navigator for its routes\n        return stateForRoute;\n      };\n\n      const state = constructState(focusedRouteState);\n      const path = getPathFromStateHelper(state, options?.config);\n\n      return path;\n    },\n    [\n      options?.enabled,\n      options?.config,\n      route?.key,\n      navigation,\n      focusedRouteState,\n      getPathFromStateHelper,\n    ]\n  );\n\n  const buildAction = React.useCallback(\n    (href: string) => {\n      if (!href.startsWith('/')) {\n        throw new Error(`The href must start with '/' (${href}).`);\n      }\n\n      const state = getStateFromPathHelper(href, options?.config);\n\n      if (state) {\n        const action = getActionFromStateHelper(state, options?.config);\n\n        return action ?? CommonActions.reset(state);\n      } else {\n        throw new Error('Failed to parse the href to a navigation state.');\n      }\n    },\n    [options?.config, getStateFromPathHelper, getActionFromStateHelper]\n  );\n\n  return {\n    buildHref,\n    buildAction,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}